\__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \_
__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/
 \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \_
__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/
 \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \_
__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/
 \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \_
__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/
 \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \_
__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/
 \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \_
__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/
\__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \_

尝试使用随附文件中的 PDF 格式，让文档更易于阅读！

= SittingDuck 为 GameMaker 开发的高级 CRT 着色器

轻量级且灵活的 CRT 着色器，旨在实现可扩展性和易于实现。

== 要使用您现有的游戏实现：

- 在游戏的第一个房间中放置一个预设对象，或通过游戏菜单中的代码创建和销毁一个对象。
- 确保您的游戏的纵横比与预设对象的纵横比相匹配。
- 就是这样！

== 高级用法：

- 只需引用持久 CRT 对象，即可从任何对象寻址着色器的所有参数。
- 例如：“crt.glow_strength += 0.1”
- 只需确保随后使用“crt.update_uniforms()”更新着色器制服
- 学习使用复古游戏开发人员针对 CRT 电视使用的效果。
- 利用隔行扫描、混合或荧光粉为您的游戏带来好处！

== 注意事项：

- 此资产需要您的游戏填充整个应用程序表面。然后将其缩小到适当的大小和纵横比。
- 例如，以 4:3 为目标的游戏可能具有 320x240 大小的视图，并且必须将视口设置为拉伸以填充整个屏幕，例如 1920x1080。
- 3D 游戏可以简单地读取 CRT 设置，如下所示：`matrix_build_projection_perspective_fov( fov, crt.aspect_ratio, znear, zfar)`
- 游戏中的 GUI 元素可以像平常一样使用“绘制 GUI”事件来绘制。
- 但是，请注意，像素化的 GUI 图形必须是原生大小（没有预烘焙缩放）。
- 您还可以选择在 CRT 屏幕上绘制 GUI，在这种情况下，您应该期望 GUI 大小与窗口大小匹配。

== 免责声明：

- 此资产不旨在产生简单的风格化效果。它旨在准确而忠实地重现像素艺术在旧显像管电视上的样子。
- 最佳设置取决于您的显示技术，包括分辨率、宽高比和子像素布局。#emph[强烈]建议您在游戏菜单中向玩家公开 CRT 设置，以便他们可以根据自己的喜好进行调整。
- 如果您想要更简单、不需要任何参数调整的东西（例如，用于游戏 jam），我个人推荐 ZIK 的 BJÖRTFX：https://zikbakguru.itch.io/bjrtfx

\__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \_
__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/
 \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \_
__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/
 \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \_
__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/
 \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \_
__/ \__/ \__/\__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/
 \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \_
__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/
 \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \_
__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/
 \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \_

= 方法：
- `crt.resize_surfaces()`
- 确保视图和应用程序表面的大小符合 CRT 着色器的要求。
- 在每个房间的开始处，将着色器与现有游戏集成时，此方法更有用。

- `crt.update_uniforms()`
- 此函数只是将所有预设对象的参数作为统一参数传递到着色器中。
- 每当这些参数发生变化时，都应调用此函数。

- `crt.crt_apply()`
- 此方法使用应用的 CRT 着色器绘制应用程序表面。
- 通常应在 Draw GUI End 事件中完成此操作。

- `crt.set_shader()`
- 此方法允许您更改正在使用的着色器。它还会为您更新制服。
- 包含 3 个选项：
- `shd_crt` - 这是具有高质量模糊和高级插值的完整 CRT 着色器。
- `shd_crt_fast` - 这是一个质量较低但功能齐全的着色器，更容易在低规格机器上运行，每个像素仅使用一半的纹理查找次数。
- `shd_raw` - 这是一个只有曲率的着色器。它可用于比较未过滤和过滤后的游戏玩法。
- 全局：`get_mouse_coords()`
- 此方法返回游戏中的鼠标坐标，以校正屏幕曲率和纵横比。
- 添加它是为了恢复 mouse_x 和 mouse_y 功能，以便于与现有项目集成。

\__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \_
__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/
 \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \_
__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/
 \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \_
__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/
 \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \_
__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/
 \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \_
__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/
 \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \_
__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/
\__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \__/ \_

= 着色器参数：

- `output_width` - [任意整数值]
- 游戏输出的宽度（以像素为单位）（通常为设备分辨率）
- 如果为 -1，则使用游戏窗口的宽度来确定值

- `output_height` - [任意整数值]
- 游戏输出的高度（以像素为单位）（通常为设备分辨率）
- 如果为 -1，则使用游戏窗口的高度来确定值。

- `game_width` - [任何正整数值]
- 复古游戏的宽度（以像素为单位）（例如，PSX 游戏为 320）

- `game_height` - [任何正整数值]
- 复古游戏的高度（以像素为单位）（例如，PSX 游戏为 240）

- `do_integer_scale` - [布尔值]
- 是否仅按整像素缩放（通常带有黑色边框）
- 适用于分辨率较低的设备，因为非均匀缩放会很突出。

- `screen_aspect_ratio` - [表达式，计算结果为实数]
- 游戏应在水平方向上压缩或拉伸多少。
- 可以输入为分数（4/3）或实数值（1.33）
- 复古游戏机和街机游戏通常具有非正方形像素，这意味着像素的宽度大于高度，反之亦然。着色器将自动处理此问题；您真正需要决定的是输出的最终纵横比。如果想获得复古感，请使用 4/3；如果想玩现代游戏，请尝试 16/9。

/****开始计时
- `screen_do_tate` - [布尔值]
- 是否旋转荧光粉掩模和扫描线（用于纵向游戏）
- 应仅与 RGBx 掩模一起使用，或禁用掩模。

- `screen_curvature_amount` - [0.0 到 1.0 之间的任何实际值]
- CRT 屏幕的曲率是多少。在大多数情况下，越少越好。
// 比如，如果这个值为0，则没有显示屏突出效果，如果值越大，则显示屏突出效果越明显


- `glow_spread` - [0.0 到 5.0 之间的任何实数值]
- 发光效果的像素分布范围

- `glow_gamma` - [1.0 到 5.0 之间的任何实数值]
- 发光淡出所基于的斜坡函数的形状
- 值越大“越圆”，值越小“越锐利”

- `glow_strength` - [0.0 到 5.0 之间的任何实数值]
- 发光效果的强度

- `glow_over_mask` - [0.0 到 1.0 之间的任何实数值]
- 发光效果在荧光掩模的黑色部分上应呈现的程度

- `image_softness` - [0.0 到 1.0 之间的任何实数值]
- 图像插值的模糊程度
- 0.0 = 五次插值，1.0 = 双线性插值

- `image_noise_amount` - [0.0 到 1.0 之间的任何实数值]
- 向图像添加多少电视静态噪声

- `image_deconvergence` - [-1.0 到 1.0 之间的任何实数值]
- 将图像的 RGB 子信号分离多少
- 这会产生类似于电影摄影中的色差的效果。

- `input_gamma` - [1.0 到 5.0 之间的任何实数值]
- 输入信号的伽马值（几乎总是 2.2）

- `output_gamma` - [1.0 到 5.0 之间的任何实数值]
- 输出信号的伽马值（几乎总是 2.2）

- `mask_type` - [Sprite asset]
- 使用哪种荧光粉掩模图案（见图 1）
- `RGBx` - 最基本的图案，但也是最暗的图案（需要亮度调整）。这是唯一一个应该与 1.0 以外的 `mask_scale` 一起使用的掩模
- GM - 此掩模利用主机显示器的子像素布局来增加亮度。最适合 `mask_scale` 为 1.0 的低分辨率设备
- RYCB - 此掩模利用主机显示器的子像素布局来增加亮度。最适合高分辨率设备，`mask_scale` 为 1.0
- YB - GM 的倒数，适用于具有非标准子像素布局的设备。最适合低分辨率设备，`mask_scale` 为 1.0
- RMCG - RYCB 的倒数，适用于具有非标准子像素布局的设备。最适合高分辨率设备，`mask_scale` 为 1.0

- `mask_strength` - [0.0 到 1.0 之间的任何实数值]
- 掩码对图像的影响程度
- 从技术上讲，1.0 是最准确的，但也会使图像变暗最多。

- `mask_scale` - [任何实数值]
- 荧光粉掩码的大小
- 在 LCD 面板上应尽可能设置为 1.0，但对于 OLED，任何值都可以。

- `mask_rgbx_repeat_on_threes` - [布尔值]
- 使用 `RGBx` 遮罩时是否裁剪黑色列
- 这可以增加亮度，但也会提高 CRT 屏幕的 TVL

- `mask_do_mirror` - [布尔值]
- 是否翻转荧光粉遮罩（用于非标准显示器）

- `mask_convert_to_shadow` - [布尔值]
- 是否将默认光圈格栅转换为阴影遮罩
- 建议在低分辨率设备中使用此选项，或者如果旨在模拟 VGA 显示器的外观。

- `mask_slot_strength` - [0.0 到 1.0 之间的任何实数]
- 应用插槽遮罩效果的强度（如果有）
- 建议在高分辨率设备中使用，或者在尝试模拟消费电视机或街机显示器的外观时使用。

- `mask_slot_height` - [整数值：0、1 或 2]
- 插槽遮罩效果的各个插槽的高度

- `scanline_strength` - [0.0 到 5.0 之间的任何实数值]
- 元素之间的区域有多暗

- `scanline_bright_fade` - [0.0 到 1.0 之间的任何实数值]
- 允许扫描线在图像明亮部分“增长”或“渗出”的程度
- 这通常被称为“光束动态”，是 CRT 上的真实现象，其中较暗的扫描线比明亮的扫描线更细。

- `scanline_shape` - [1.0 到 2.0 之间的任何实数值]
- 电子束的形状
- 1.0 = 线性，像三角波，2.0 = 二次，圆形

- `border_width` - [0.0 到 10.0 之间的任何实数值]
- CRT 屏幕外的边框有多宽
- 将其设置为 0.0 可有效消除边框。

- `border_brightness` - [0.0 到 1.0 之间的任何实数值]
- 边框上的屏幕反射应有多亮

- `viewport_zoom` - [任何实数值]
- CRT 屏幕放大多少（对屏幕截图有用）

- `viewport_shift_x` - [任何实数值]
- CRT 屏幕水平移动多少（可能是为了给 GUI 留出空间？）

- `viewport_shift_y` - [任何实数值]
- CRT 屏幕垂直移动多少（可能是为了给 GUI 留出空间？）

- `post_brightness` - [任何实数值]
- 在屏幕上显示之前改变亮度多少
- 这通常应该是您的最后手段；首先尝试更改其他参数。

- `shader` - [着色器资源]
- 使用哪个 CRT 着色器进行绘制。您有 3 个选项：
- `shd_crt` - 功能齐全、高质量着色器。价格昂贵。
- `shd_crt_fast` - 功能仍然完整，但视觉质量较低。速度更快。
- `shd_raw` - 仅处理曲率和纵横比。用于比较。
- `gui_user_event` - [GM.EventName、GM.EventNumber 数组]
- 用于游戏对象绘制到 GUI 的事件。
- 在此事件中完成的任何绘制都会被捕获，因此它将出现在 CRT 屏幕上。
- CRT 对象的绘制事件永远不会被捕获。
- 如果您想在 CRT 屏幕上绘制 GUI，请将其更改为用户事件。
- 为了提高性能，请使用用户事件并将所有 GUI 绘制移至该事件！

- `crt_draw_event` - [选择“绘制 GUI 开始”、“绘制 GUI”或“绘制 GUI 结束”]
- 何时捕获所有绘制、应用着色器并发送到显示器
- 如果您想在 CRT 屏幕顶部绘制 GUI，请使用“绘制 GUI 开始”。
- 在大多数情况下，使用“绘制 GUI 结束”，目的是捕获 GUI 元素。

- `do_overlay` - [布尔值]
- 是否在 CRT 屏幕上方或下方绘制覆盖层

- `overlay_over_screen` - [布尔值]
- 覆盖层应该位于屏幕前面还是后面

- `overlay_image` - [精灵资产]
- 您将用作覆盖层的图像
- 如果在 CRT 屏幕前面绘制，则图像需要透明。

  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \_
__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/ 
  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \_
__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/ 
  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \_
__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/ 
  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \_
__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/ 
  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \_
__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/ 
  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \_
__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/ 
  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \_

Try the PDF in the included files for an easier-to-read document!

= SittingDuck's Advanced CRT Shader for GameMaker

A lightweight and flexible CRT shader that aims to be scalable and easy to implement.

== To implement with your existing game:

 - Place a preset object in the first room of your game or create & destroy one via code in your game's menu.
 - Ensure that your game's aspect ratio matches that of the preset object.
 - That's it!

== Advanced use:

- All parameters of the shader are addressable from any object just by referencing the persistent CRT object.
	- For example: "crt.glow_strength += 0.1"
	- Just make sure to update the shader uniforms afterward with "crt.update_uniforms()"
- Learn to use effects that retro game developers used with CRT TVs in mind.
	- Exploit interlacing, blending, or phosphors for your game's benefit!

== Notes:

- This asset expects your game to fill the entire application surface. It is then scaled down to the appropriate size and aspect ratio.
	- As an example, a game targeting 4:3 might have a view of size 320x240, with a viewport that must be set to stetch to fill the whole screen at something like 1920x1080.
	- 3D games can simply read the CRT setting, like so: `matrix_build_projection_perspective_fov( fov, crt.aspect_ratio, znear, zfar)`
- GUI elements in your game can be drawn using the "Draw GUI" event like normal.
	- However, be aware that pixelated GUI graphics must be natively-sized (without prebaked scaling).
 - You can also choose to draw a GUI over top the CRT screen, in which case you should expect the GUI size to match the window size.

== Disclaimer:

- This asset is not intended to produce a simple stylized effect. It aims to accurately and faithfully recreate what pixel art used to look like on old tube TVs.
 - The optimal settings will depend on your display technology, including resolution, aspect ratio, and subpixel layout. It is #emph[strongly] recommended that you expose the CRT settings to your players in your game's menu, so that they can tweak it to their liking.
- If you want something a bit simpler that doesn't require any parameter tuning (e.g., for game jams), I personally recommend BJÖRTFX by ZIK: https://zikbakguru.itch.io/bjrtfx

  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \_
__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/ 
  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \_
__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/ 
  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \_
__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/ 
  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \_
__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/ 
  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \_
__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/ 
  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \_
__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/ 
  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \_

= Methods:
- `crt.resize_surfaces()`
	- Ensures that the view and application surfaces are the size that the CRT shader expects.
	- This method is more useful when integrating the shader with an existing game, at the start of every room.
 
- `crt.update_uniforms()`
	- This function simply passes all of the preset object's parameters into the shader as uniforms.
	- It should be called whenever these parameters change.
 
- `crt.crt_apply()`
	- This method draws the application surface with the CRT shader applied.
	- It should typically be done in the Draw GUI End event.
 
- `crt.set_shader()`
	- This method allows you to change the shader being used. It also updates the uniforms for you.
	- Included are 3 options:
		- `shd_crt` - This is the full CRT shader with high quality blur and advanced interpolation.
		- `shd_crt_fast` - This is a lower-quality but still fully-featured shader that is easier to run on low-spec machines, using only half as many texture lookups per pixel.
		- `shd_raw` - This is a shader with curvature and nothing else. It's useful for comparing unfiltered to filtered gameplay.
  
- Global: `get_mouse_coords()`
    - This method returns the in-game mouse coordinates, correcting for the screen curvature and aspect ratio.
	- It was added to restore mouse_x and mouse_y functionality for ease of integrating with existing projects.

  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \_
__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/ 
  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \_
__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/ 
  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \_
__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/ 
  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \_
__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/ 
  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \_
__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/ 
  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \_
__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/ 
  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \_

 = Shader parameters:

- `output_width` - [Any integer value]
 - The width of the game's output in pixels (typically the device resolution)
 - If -1, the width of the game window is used to determine the value
 
- `output_height` - [Any integer value]
 - The height of the game's output in pixels (typically the device resolution)
 - If -1, the height of the game window is used to determine the value.

- `game_width` - [Any positive integer value]
 - The width of the retro game in pixels (e.g., 320 for PSX games)

- `game_height` - [Any positive integer value]
 - The height of the retro game in pixels (e.g., 240 for PSX games)

- `do_integer_scale` - [Boolean]
 - Whether or not to scale in whole pixels only (typically with a black border)
 - Useful for lower-resolution devices where non-uniform scaling can stand out.

- `screen_aspect_ratio` - [Expression, evaluates to real]
 - How much the game should be squished or stretched horizontally.
 - Can be input as a fraction (4/3) or as a real value (1.33)
 - Retro consoles and arcade games often had non-square pixels, meaning the pixels were wider than they were tall or vice versa. The shader will take care of this automatically; all you really need to decide is the final aspect ratio of the output. For a retro feel, go with 4/3, or for modern games, try 16/9.

- `screen_do_tate` - [Boolean]
 - Whether or not to rotate the phosphor mask and scanlines (for portrait games)
 - Should only be used with the RGBx mask, or with the mask disabled.

- `screen_curvature_amount` - [Any real value between 0.0 and 1.0]
 - How much curvature the CRT screen will have. Less is more in most cases.

- `glow_spread` - [Any real value between 0.0 and 5.0]
 - How wide the glow effect will spread in pixels

- `glow_gamma` - [Any real value between 1.0 and 5.0]
 - The shape of the ramp function the glow fadeout is based on
 - Larger values are "rounder" while lower values are "sharper"

- `glow_strength` - [Any real value between 0.0 and 5.0]
 - How strong the glow effect is

- `glow_over_mask` - [Any real value between 0.0 and 1.0]
 - How much the glow effect should bloom over the black parts of the phosphor mask

- `image_softness` - [Any real value between 0.0 and 1.0]
 - How blurry to make the image interpolation
 - 0.0 = quintic interpolation, 1.0 = bilinear interpolation

- `image_noise_amount` - [Any real value between 0.0 and 1.0]
 - How much TV static to add to the image

- `image_deconvergence` - [Any real value between -1.0 and 1.0]
 - How much to separate the RGB subsignals of the image
 - This produces an effect similar to chromatic aberration in filmography.

- `input_gamma` - [Any real value between 1.0 and 5.0]
 - The gamma of the input signal (should almost always be 2.2)

- `output_gamma` - [Any real value between 1.0 and 5.0]
 - The gamma of the output signal (should almost always be 2.2)

- `mask_type` - [Sprite asset]
 - Which phosphor mask pattern to use (see Figure 1)
  - `RGBx` - The most basic pattern, but also the darkest (requires brightness adjustment). This is the only mask you should use with a `mask_scale` other than 1.0
  - GM - This mask takes advantage of the host display's subpixel layout to increase brightness. Best suited for low-res devices with `mask_scale` of 1.0
  - RYCB - This mask takes advantage of the host display's subpixel layout to increase brightness. Best suited for high-res devices with `mask_scale` of 1.0
  - YB - Inverse of GM for devices with a nonstandard subpixel layout. Best suited for low-res devices with `mask_scale` of 1.0
  - RMCG - Inverse of RYCB for devices with a nonstandard subpixel layout. Best suited for high-res devices with `mask_scale` of 1.0

- `mask_strength` - [Any real value between 0.0 and 1.0]
 - How strongly the mask will affect the image
 - 1.0 is technically speaking the most accurate, but also darkens the image the most.

- `mask_scale` - [Any real value]
 - The size of the phosphor mask
 - Should be set to 1.0 whenever possible on LCD panels, but for OLEDs anything goes.

- `mask_rgbx_repeat_on_threes` - [Boolean]
 - Whether or not to crop the black column when using the `RGBx` mask
 - This can increase brightness, but also raises the TVL of the CRT screen

- `mask_do_mirror` - [Boolean]
 - Whether or not to flip the phosphor mask (for nonstandard displays)

- `mask_convert_to_shadow` - [Boolean]
 - Whether or not to convert the default aperture grille into a shadow mask
 - This option is recommended for low-res devices, or if aiming to simulate the look of a VGA monitor.

- `mask_slot_strength` - [Any real value between 0.0 and 1.0]
 - How strongly to apply a slot mask effect (if at all)
 - Recommended for high-res devices, or when trying to simulate the look of a consumer TV set or arcade monitor.

- `mask_slot_height` - [Integer value: 0, 1, or 2]
 - The height of the individual slots for the slot mask effect

- `scanline_strength` - [Any real value between 0.0 and 5.0]
 - How dark the area between electron beams is

- `scanline_bright_fade` - [Any real value between 0.0 and 1.0]
 - How much to allow scanlines to "grow" or "bleed" on bright parts of the image
 - This is often referred to as "beam dynamics," and was a real phenomenon on CRTs where darker scanlines were thinner than bright ones.

- `scanline_shape` - [Any real value between 1.0 and 2.0]
 - The shape of the electron beam
 - 1.0 = linear, like a triangle wave, 2.0 = quadratic, a round shape

- `border_width` - [Any real value between 0.0 and 10.0]
 - How wide to make the border outside of the CRT screen
 - Setting this to 0.0 effectively removes the border.

- `border_brightness` - [Any real value between 0.0 and 1.0]
 - How bright the screen reflection on the border should be

- `viewport_zoom` - [Any real value]
 - How much to zoom in on the CRT screen (useful for screenshots)

- `viewport_shift_x` - [Any real value]
 - How much to shift the CRT screen horizontally (perhaps to make room for a GUI?)

- `viewport_shift_y` - [Any real value]
 - How much to shift the CRT screen vertically (perhaps to make room for a GUI?)

- `post_brightness` - [Any real value]
 - How much to alter the brightness right before displaying to the screen
 - This should usually be your last resort; try changing other parameters first.

- `shader` - [Shader asset]
 - Which CRT shader to use for drawing. You have 3 options:
  - `shd_crt` - Fully-featured, high quality shader. Expensive.
  - `shd_crt_fast` - Still feature-complete, but lower visual quality. Faster.
  - `shd_raw` - Only handles curvature and aspect ratio. For comparisons.

- `gui_user_event` - [Array of GM.EventName, GM.EventNumber]
 - Event used for game objects to draw to the GUI.
 - Any drawing done in this event is captured, so it will appear on the CRT screen.
 - The CRT object's draw events will never be captured.
 - If you want to draw your GUI on top of the CRT screen, change this to a user event.
 - For improved performance, use a user event and move all your GUI drawing to it!

- `crt_draw_event` - [Choice of "Draw GUI Begin", "Draw GUI", or "Draw GUI End"]
 - When to capture all drawing, apply the shader, and send to the display
 - Use "Draw GUI Begin" if you want to draw a GUI on top of the CRT screen.
 - Use "Draw GUI End" in most other cases, with the goal of capturing GUI elements.

- `do_overlay` - [Boolean]
 - Whether or not to draw an overlay over or under the CRT screen

- `overlay_over_screen` - [Boolean]
 - Whether or not the overlay should be in front of the screen or behind it

- `overlay_image` - [Sprite asset]
 - The image you will be using as an overlay
 - If drawing in front of the CRT screen, there needs to be transparency in the image.

